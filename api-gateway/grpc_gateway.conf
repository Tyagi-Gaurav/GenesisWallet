#Format entries for access log. HTTP method is not included, as all gRPC requests use POST.
log_format grpc_json escape=json '{"timestamp":"$time_iso8601",'
           '"client":"$remote_addr","uri":"$uri","http-status":$status,'
           '"grpc-status":$grpc_status,"upstream":"$upstream_addr"'
           '"rx-bytes":$request_length,"tx-bytes":$bytes_sent}';

#Evaluates a new variable $grpc_status based on if it arrives in trailer or header
map $upstream_trailer_grpc_status $grpc_status {
    default $upstream_trailer_grpc_status; # grpc-status is usually a trailer
    ''      $sent_http_grpc_status; # Else use the header, whatever its source
}

server {
    listen 8080 http2; # Plaintext port: In production, comment out to disable plaintext port
    #listen 443   http2 ssl; 
    server_name  api.wallet.com;
    access_log   /var/log/nginx/grpc_log.json grpc_json;

    # TLS config
    #ssl_certificate      /etc/ssl/certs/grpc.example.com.crt;
    #ssl_certificate_key  /etc/ssl/private/grpc.example.com.key;
    #ssl_session_cache    shared:SSL:10m;
    #ssl_session_timeout  5m;
    #ssl_ciphers          HIGH:!aNULL:!MD5;
    #ssl_protocols        TLSv1.2 TLSv1.3;

    # Routing
    location /user. {
        grpc_pass grpc://user_service;
        #If the backend is configured for TLS, we can use the grpcs:// scheme to secure 
        #the gRPC connection with end‑to‑end encryption
    }

    # Error responses
    include conf.d/errors.grpc_conf; # gRPC-compliant error responses
    default_type application/grpc;   # Ensure gRPC for all error responses
}

#Backend gRPC servers
upstream user_service {
    zone user_service 64k;
    server local.user-app:50051;
}